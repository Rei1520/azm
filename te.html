<!DOCTYPE html>
<html>
<head>
<title>DrawESP</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script>
setButtonImage('https://i.postimg.cc/6qGf3wBq/image.png');  
</script>  
<style type="text/css">
* {
    /*默认文字颜色*/
    color: #000;
    font-size: 13px;
    font-family: Arial, sans-serif;
    -webkit-tap-highlight-color: transparent;
    outline: none;
}
*:not(input,checkbox,textarea) {
    /*禁止文本选择*/
   -webkit-touch-callout: none;
   -webkit-user-select: none;
   user-select: none; /* Non-prefixed version, currently */
}
  .lan02 {
        font-weight: 500;
        position: relative;
        font-size: 15px;
        top: 10px;
        left: 0px;
      }    
html,body{
    padding: 0;
    margin: 0;
    width: 100%;
    height: 100%;
    background-color: transparent;
}

.popup_container {
    position:absolute;
    z-index: 1000;
    left:50%;
    top:0;
}

#H5AlertView {
    width:500px;
    height:300px;
    position:absolute;
    left:-250px; top:50px;
    text-align:left;
    zoom:0.8;
}

#title-text{
padding-top:0px;
font-size:18px;
color: #494949;
}

#info-text{
padding:10px;
color:#494949;
}

#content-view{
z-index:0;
background: #fff;
position: relative;
top: 0px;
border: 1px solid #E8E8E8;
border-radius:5px;
padding: 10px;
}
      .switch-btn {
        cursor: pointer;
        width: 50px;
        height: 30px;
        position: relative;
        top: 3px;
        right: 10px;
        border: 0px solid #dfdfdf;
        background-color: #e9e9e9;
        box-shadow: #dfdfdf 0 0 0 0 inset;
        border-radius: 15px;
        background-clip: content-box;
        display: inline-block;
        -webkit-appearance: none;
        user-select: none;
        outline: none;
        float: right;
      }

      .switch-btn:before {
        content: '';
        width: 26px;
        height: 26px;
        position: absolute;
        top: 2px;
        left: 2px;
        ;
        border-radius: 20px;
        background-color: white;
        box-shadow: none;
        border: 0;
      }

      .switch-btn:checked {
        border-color: #00e280;
        box-shadow: #00e280 0 0 0 16px inset;
        background-color: #00e280;
      }

      .switch-btn:checked:before {
        left: 22px;
      }

      .switch-btn.switch-btn-animbg {
        transition: background-color ease .4s;
      }

      .switch-btn.switch-btn-animbg:before {
        transition: left .3s;
      }

      .switch-btn.switch-btn-animbg:checked {
        box-shadow: #dfdfdf 0 0 0 0 inset;
        background-color: black;
        transition: border-color .4s, background-color ease .4s;
      }

      .switch-btn.switch-btn-animbg:checked:before {
        transition: left .3s;
      }

      /* 滚动条整体部分 */

      .scrollbar {
        overflow-x: hidden;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .scrollbar::-webkit-scrollbar {
        width: 0px;
        /* 纵向滚动条宽度 */
        height: 5px;
        /* 横向滚动条高度 */
        background-color: #F5F5F5;
        /* 滚动条整体背景，一般被覆盖着 */
      }

      /* 滚动条的轨道（里面装有Thumb） */
      .scrollbar::-webkit-scrollbar-track {
        -webkit-box-shadow: inset 0 0 6px rgba(45, 45, 45, .41);
        /* 滚动条轨道阴影 */
        /*border-radius: 10px; /* 滚动条轨道圆角 */
        background-color: rgba(45, 45, 45, .41);
        /* 滚动条轨道背景 */
      }

      /* 滚动条里面的滑块 */
      .scrollbar::-webkit-scrollbar-thumb {
        border-radius: 15px;
        /* 滚动条滑块圆角 */
        -webkit-box-shadow: inset 0 0 6px rgba(45, 45, 45, .41);
        /* 滚动条滑块阴影 */
        background-color: rgba(45, 45, 45, .41);
        /* 滚动条滑块颜色 */
      }

.content .slide .block{
width:55%;
height:3px;
margin:24px 0;
border-radius:3px;
background-color:#eee;
position:relative;
}
.content .slide .block #progress{
width:0;
height:3px;
border-radius:3px;
background-color:#2196f3;
}
.content .slide .block #circular{
width:24px;
height:24px;
border-radius:50%;
background-color:white;
border:1px solid #eee;
position:absolute;
left:0;
top:0;
transform:translateY(-50%);
}
.content .btn-page .item{
display:block;
width:100px;
height:30px;
border-radius:5px;
background-color:#2196f3;
border:none;
font-size:16px;
color:white;
user-select:none;
-webkit-user-select:none;
-moz-user-select:none;
}
</style>
</head>
<body>
  <div class="popup_container">
    <div id="H5AlertView">
      <script>
  function draw(fps) {

      if (window.draw_state == 1) {
        window.draw_state = 0;
        clearCtx();
      } else {
        window.draw_state = 1;
      }
    }
      </script>    
<div id="content" class="content" style="filter: opacity(1);">
<div class="popup_container">
<div id="H5AlertView">
<div id="content-view">
<div id="title-text">H5GG-流畅单绘制</div>
<div style="border-top: 1px solid gray;padding:5px; margin:0px;">   
<table id="bodyView" width="100%" style="table-layout:fixed;height:100%;">    
</div>
<label><span class=lan02>开启绘制</span><input class="switch-btn switch-btn animbg" type="checkbox" onclick="draw()"></label>
<br><br><br>  
<label><span class=lan02>射线</span><input class="switch-btn switch-btn animbg" type="checkbox" onclick="onSwitch(event, 'line')"></label>
<br><br>
<label><span class=lan02>方框</span><input class="switch-btn switch-btn animbg" type="checkbox" onclick="onSwitch(event, 'box')"></label>
<br><br>
<label><span class=lan02>血条</span><input class="switch-btn switch-btn animbg" type="checkbox" onclick="onSwitch(event, 'hp')"></label>
<br><br>
<label><span class=lan02>距离</span><input class="switch-btn switch-btn animbg" type="checkbox" onclick="onSwitch(event, 'dis')"></label>
<br><br>      
<div class="slide">
<div class="lan02">绘制刷新率: <span id="slide-value">60</span>ms/次</div>
<div class="block">
<div id="progress"></div>
<div id="circular" ontouchstart="onTouchstart(event)" ontouchmove="onTouchmove(event)"></div>
</div>
</div>
</div>
</div>
</div>
</div>
<script>
    // 滑块
    const onTouchstart = ({ touches }) => {
        const { clientX, target } = touches[0]
        touchStartX = parseInt(clientX)
        menuLastX = target.offsetLeft
    }
    const onTouchmove = ({ touches, preventDefault }) => {
        const min = 60
        const max = 300
        const { clientX, target } = touches[0]
        let distanceX = (clientX - touchStartX) + menuLastX
        if (distanceX <  0) distanceX = 0
        else if (distanceX > 236) distanceX = 236
        draw.slide = Math.ceil(distanceX * ((max - min) / 236) + min)
        document.getElementById('slide-value').innerText = draw.slide
        document.getElementById('progress').style.width = `${distanceX}px`
        target.style.left = `${distanceX}px`
    }
  document.body.addEventListener('touchstart', function () { });

  setWindowDrag(0, 0, 0, 0);

  setButtonImage();

  var iosScale = window.devicePixelRatio;
  var sWidth = 0;
  var sHeight = 0;
  const showInfo = {};
  const onSwitch = ({ target }, type) => {
    showInfo[type] = !showInfo[type];
    if (target.className.indexOf('is-active') === -1) {
      target.className += ' is-active'
    } else {
      target.className = target.className.replace(new RegExp(' is-active'), '')
    }
  }
  var canvasDom = document.createElement("canvas");
  document.body.appendChild(canvasDom);
  canvasDom.style.height = "100%";
  canvasDom.style.width = "100%";

  var layout = function () {

    if (window.lastorientation == window.orientation) return;
    window.lastorientation = window.orientation;

    if (Math.abs(window.orientation) == 90) {
      setWindowRect(0, 0, window.screen.height, window.screen.width);
      canvasDom.width = window.screen.height * iosScale;
      canvasDom.height = window.screen.width * iosScale;
      sWidth = window.screen.height;
      sHeight = window.screen.width;
    } else {
      setWindowRect(0, 0, window.screen.width, window.screen.height);
      canvasDom.height = window.screen.height * iosScale;
      canvasDom.width = window.screen.width * iosScale;
      sWidth = window.screen.width;
      sHeight = window.screen.height;
    }
  }

  layout();
  window.addEventListener("orientationchange", layout, false);

  setButtonAction(function () {

    var menu = document.querySelector("#H5AlertView");
    if (menu.style.display == 'none') {
      menu.style.display = 'block';
      setWindowTouch(true);
    } else {
      menu.style.display = 'none';
      setWindowTouch(false);
    }
  });


  var ctx = canvasDom.getContext('2d');
  setLineWidth(iosScale);
  var fontFamily = " Arial";

  var cacheTimer = null;
  var drawTimer = null;
  var actorCache = [];

  var baseAddr = Number(h5gg.getRangesList(0)[0].start);
  var GWorld = 0;
  function drawCache() {
    if (isNull(GWorld)) return;
    var Level = readLong(GWorld + 0x90);
    var ActorArray = readLong(Level + 0xA0);
    var ActorCount = readInt(Level + 0xA8);
    var tempArr = [];
    for (var i = 0; i < ActorCount; i++) {
      var actor = readLong(ActorArray + i * 8);
      if (isNull(actor)) continue;
      var hpmax = readFloat(actor + 0xdc8);
      if (hpmax == 100 || hpmax == 110 || hpmax == 120 || hpmax == 130 || hpmax == 140 || hpmax == 150 || hpmax == 160 || hpmax == 170 || hpmax == 180 || hpmax == 190 || hpmax == 200) {
        tempArr.push(actor);
      }
    }
    actorCache = tempArr;
  }

  function shadowDraw() {
    clearCtx();
    GWorld = readLong(baseAddr + 0xB5F2CA8);
    if (isNull(GWorld)) return;
    var NetDriver = readLong(GWorld + 0x98);
    var ServerConnection = readLong(NetDriver + 0x88);
    var localPlayerController = readLong(ServerConnection + 0x30);
    var mySelf = readLong(localPlayerController + 0x550);
    var teamCopy = readInt(mySelf + 0xa60);
    myTeam = teamCopy <= 100 ? teamCopy : myTeam
    var playerCameraManager = readLong(localPlayerController + 0x5d8);
    if (isNull(playerCameraManager)) return;
    var povAddr = playerCameraManager + 0x1120 + 0x10;
    var camViewInfo = {
      Location: {
        X: readFloat(povAddr),
        Y: readFloat(povAddr + 4),
        Z: readFloat(povAddr + 4 + 4)
      },
      Rotation: {
        Pitch: readFloat(povAddr + 0x18),
        Yaw: readFloat(povAddr + 0x18 + 4),
        Roll: readFloat(povAddr + 0x18 + 4 + 4)
      },
      FOV: readFloat(povAddr + 0x24)
    }

    var tempMatrix = RotatorToMatrix(camViewInfo.Rotation);

    var playerCout = 0;
    for (var i = 0; i < actorCache.length; i++) {
      var actor = actorCache[i];
      if (mySelf == actor) continue;
      
      var bDead = readInt(actor + 0xe28)
      if (bDead != 2) continue;

      var team = readInt(actor + 0xa60);
      if (team == -1) continue;
      if (myTeam == team) continue;

      var hp = readFloat(actor + 0xdc0);

      var rootComponent = readLong(actor + 0x268);

      if (isNull(rootComponent)) continue;
      var worldPos = {

        X: readFloat(rootComponent + 0x1B0),
        Y: readFloat(rootComponent + 0x1B0 + 4),
        Z: readFloat(rootComponent + 0x1B0 + 4 + 4)
      }

      var distX = (worldPos.X - camViewInfo.Location.X) / 100;
      var distY = (worldPos.Y - camViewInfo.Location.Y) / 100;
      var distance = (distX * distX) + (distY * distY);
      var distZ = (worldPos.Z - camViewInfo.Location.Z) / 100;
      distance = Math.ceil(Math.sqrt((distZ * distZ) + distance));

      var zb1 = {
        X: worldPos.X,
        Y: worldPos.Y,
        Z: worldPos.Z + 80.0
      }
      var zb2 = {
        X: worldPos.X,
        Y: worldPos.Y,
        Z: worldPos.Z - 80.0
      }
      var fkzb1 = world2Screen(zb1, camViewInfo, tempMatrix);
      var fkzb2 = world2Screen(zb2, camViewInfo, tempMatrix);
      var fkgao = fkzb2.Y - fkzb1.Y;
      var fkkuan = fkgao / 2;
      //bIsAI
      var bIsAI = Number(h5gg.getValue(actor + 0xa7c, "U8"));

			//Pawn* Pawn
			var selflocalPlayerbase = readLong(localPlayerController + 0x550);
			//CharacterWeaponManagerComponent* WeaponManagerComponent;
			var weaponManagerComponent = readLong(selflocalPlayerbase + 0x29d0);
			//STExtraWeapon* CachedCurUseWeapon
			var cachedCurUseWeapon = readLong(weaponManagerComponent + 0x308);
			//STExtraShootWeaponComponent* ShootWeaponComponent
			var shootWeaponComponent = readLong(cachedCurUseWeapon + 0x1098);
			//STExtraShootWeapon* OwnerShootWeapon
			var ownerShootWeapon = readLong(shootWeaponComponent + 0x290);
			//ShootWeaponEntity* ShootWeaponEntityComp
			var shootWeaponEntityComp = readLong(ownerShootWeapon + 0x12e0);



      name = "";
      var actorInfo = {
        x: fkzb1.X,
        y: fkzb1.Y,
        w: fkkuan,
        h: fkgao,
        hp: hp,
        isAI: bIsAI,
        team: team,
        dis: distance,
        siwang: bDead,
        distZ: distZ,

      };
      shadowInfo(actorInfo);
      playerCout++;
      if (team == myTeam) {
        playerCout--;
      }

      if (team == -1) {
        playerCout--;
      }

    }


     drawText(playerCout, sWidth / 2.0, 14,15, "yellow", true);}

  function shadowInfo(objectInfo) {
    var color = "#00FF00";
    if (objectInfo.team != objectInfo.MT) {
      

      if (showInfo.line) {//射线
        drawLine(sWidth / 2, 10, objectInfo.x, objectInfo.y - 18, color);
      }

      if (showInfo.dis) {
					drawText(objectInfo.dis, objectInfo.x, objectInfo.y - 21, 6, "#FFF", "center", true);
      }
      
     if (showInfo.box) {
        var temColor = objectInfo.isAI?"#FFF":"#00ff00";
        drawMyRect(objectInfo.x - objectInfo.w / 2, objectInfo.y, objectInfo.w, objectInfo.h, 1.6, temColor);
        //方框
      }

      if(showInfo.hp){
					drawRoundRect(objectInfo.x, objectInfo.y - 11, Math.ceil(objectInfo.hp), 8, objectInfo.hp <= 30 ? "red" :
						"#28ff1d", 5, false);
        }
      }
    }

  function clearCtx() {
    ctx.clearRect(0, 0, canvasDom.width, canvasDom.height);
  }

  function setLineWidth(w) {
    ctx.lineWidth = w;
  }

  function drawRoundRect(x, y, w, h, r, color, isFill = true) {
    x *= iosScale;
    y *= iosScale;
    w *= iosScale;
    h *= iosScale;
    r *= iosScale;

    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.globalAlpha = 1;
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    if (isFill) {
      ctx.fill();
    } else {
      ctx.stroke();
    }
    ctx.closePath();
  }

  function drawText(text, x, y, size, color, isFill = true) {
    x *= iosScale;
    y *= iosScale;
    size *= iosScale;

    ctx.beginPath();
    ctx.textAlign = "center";
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.globalAlpha = 1;
    ctx.font = size + 'px' + fontFamily;
    if (isFill) {
      ctx.fillText(text, x, y + size);
    } else {
      ctx.strokeText(text, x, y + size);
    }
    ctx.closePath();
  };

  function drawMyRect(x, y, width, height, lineWidth, color) {

    x *= iosScale;
    y *= iosScale;
    width *= iosScale;
    height *= iosScale;

    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;

    ctx.beginPath();

    ctx.moveTo(x, y);
    ctx.lineTo(Number(x) + Number(width) / 6, y);
    ctx.closePath();

    ctx.moveTo(x, y);
    ctx.lineTo(x, Number(y) + Number(height / 9));
    ctx.closePath();

    ctx.moveTo(Number(x) + Number(width) - Number(width) / 6, y);
    ctx.lineTo(Number(x) + Number(width), y);
    ctx.closePath();

    ctx.moveTo(Number(x) + Number(width), y);
    ctx.lineTo(Number(x) + Number(width), Number(y) + Number(height / 9));
    ctx.closePath();

    ctx.moveTo(Number(x), Number(y) + Number(height));
    ctx.lineTo(Number(x), Number(y) + Number(height) - Number(height / 9));
    ctx.closePath();

    ctx.moveTo(Number(x), Number(y) + Number(height));
    ctx.lineTo(Number(x) + Number(width) / 6, Number(y) + Number(height));

    ctx.moveTo(Number(x) + Number(width), Number(y) + Number(height));
    ctx.lineTo(Number(x) + Number(width) - (width / 6), Number(y) + Number(height));

    ctx.moveTo(Number(x) + Number(width), Number(y) + Number(height));
    ctx.lineTo(Number(x) + Number(width), Number(y) + Number(height) - Number(height / 9));
    ctx.closePath();

    ctx.stroke();
  }




  function drawLine(x1, y1, x2, y2, color) {
    x1 *= iosScale;
    y1 *= iosScale;
    x2 *= iosScale;
    y2 *= iosScale;



    // ctx.lineWidth = 1.6;
    ctx.lineWidth = 0.6;
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.globalAlpha = 1;
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
  }

	/***************内存*******************/
  function readInt(addr) {
    return Number(h5gg.getValue(addr, "I32"));
  }

  function readLong(addr) {
    return Number(h5gg.getValue(addr, "I64"));
  }

  function readFloat(addr) {
    return Number(h5gg.getValue(addr, "F32"));
  }

  function isNull(addr) {
    return (addr < 0x100000000 || addr > 0x300000000);
  }
	/***************UE4*******************/
  function RotatorToMatrix(rotation) {
    var radPitch = rotation.Pitch * (Math.PI / 180.0);
    var radYaw = rotation.Yaw * (Math.PI / 180.0);
    var radRoll = rotation.Roll * (Math.PI / 180.0);

    var SP = Math.sin(radPitch);
    var CP = Math.cos(radPitch);
    var SY = Math.sin(radYaw);
    var CY = Math.cos(radYaw);
    var SR = Math.sin(radRoll);
    var CR = Math.cos(radRoll);

    var matrix = new Array(16).fill(0);

    matrix[0] = (CP * CY);
    matrix[1] = (CP * SY);
    matrix[2] = (SP);
    matrix[3] = 0;

    matrix[4] = (SR * SP * CY - CR * SY);
    matrix[5] = (SR * SP * SY + CR * CY);
    matrix[6] = (-SR * CP);
    matrix[7] = 0;

    matrix[8] = (-(CR * SP * CY + SR * SY));
    matrix[9] = (CY * SR - CR * SP * SY);
    matrix[10] = (CR * CP);
    matrix[11] = 0;

    matrix[12] = 0;
    matrix[13] = 0;
    matrix[14] = 0;
    matrix[15] = 1;

    return matrix;
  }

  function vectorDot(lhs, rhs) {
    return (((lhs.X * rhs.X) + (lhs.Y * rhs.Y)) + (lhs.Z * rhs.Z));
  }

  function world2Screen(worldLocation, camViewInfo, tempMatrix) {
    // var tempMatrix = RotatorToMatrix(camViewInfo.Rotation);

    var vAxisX = {
      X: tempMatrix[0],
      Y: tempMatrix[1],
      Z: tempMatrix[2]
    };
    var vAxisY = {
      X: tempMatrix[4],
      Y: tempMatrix[5],
      Z: tempMatrix[6]
    };
    var vAxisZ = {
      X: tempMatrix[8],
      Y: tempMatrix[9],
      Z: tempMatrix[10]
    };

    var vDelta = {
      X: worldLocation.X - camViewInfo.Location.X,
      Y: worldLocation.Y - camViewInfo.Location.Y,
      Z: worldLocation.Z - camViewInfo.Location.Z
    };

    var vTransformed = {
      X: vectorDot(vDelta, vAxisY),
      Y: vectorDot(vDelta, vAxisZ),
      Z: vectorDot(vDelta, vAxisX)
    };

    if (vTransformed.Z < 1.0) {
      vTransformed.Z = 1.0;
    }

    var fov = camViewInfo.FOV;
    var screenCenterX = (sWidth / 2.0);
    var screenCenterY = (sHeight / 2.0);

    var re = {
      X: (screenCenterX + vTransformed.X * (screenCenterX / Math.tan(fov * (Math.PI / 360.0))) /
        vTransformed
          .Z),
      Y: (screenCenterY - vTransformed.Y * (screenCenterX / Math.tan(fov * (Math.PI / 360.0))) /
        vTransformed
          .Z)
    };

    return re;
  }


  cacheTimer = setInterval(function () {
    drawCache();
  }, 1000);
  drawTimer = setInterval(function () {
    if (window.draw_state) {
      shadowDraw();

      if (!window.fpscount) window.fpscount = 0;
      if (!window.fpstime) window.fpstime = performance.now();
      window.fpscount++;
      if ((performance.now() - window.fpstime) > 4000) {
        window.fps = window.fpscount;
        window.fpstime = performance.now();
        window.fpscount = 0;
      }
      ctx.textBaseline = "top";
      ctx.textAlign = "center";
      ctx.font = '0px "Arial, sans-serif"';
      ctx.fillStyle = "black";
      if (window.fps) ctx.fillText(window.fps, 80, 30);
    }
  }, 15);
   

    /***************绘图相关*******************/
		//绘制圆形 起点xy，圆形弧度，大小，颜色，线宽，是否填充（圆形血条，背敌）
		function drawRoundRect(x, y, num, size, color, lineWidth, isFill = true) {
			x *= iosScale;
			y *= iosScale;
			size *= iosScale;

			if (num === 100) num = 1;
			else if (num > 0) num = 1 - num / 100;
			const d2a = n => n * Math.PI / 180;

			ctx.beginPath();
			ctx.lineWidth = lineWidth;
			ctx.arc(x, y, size, d2a(num * 360 - 90), d2a(-90), false);
			if (isFill) {
				ctx.fillStyle = color;
				ctx.fill();
			} else {
				ctx.strokeStyle = color;
				ctx.stroke();
			}
			ctx.closePath();
		}

	/***************缓存*******************/

		cacheTimer = setInterval(function() {
			drawCache();
		}, 3000); //一秒缓存一次
</script>
</body>
</html>
